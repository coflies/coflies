package common

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"

	log "github.com/sirupsen/logrus"
	yaml "gopkg.in/yaml.v2"
)

type LanguageType string

// Language Type
const (
	COMPILER    LanguageType = "compiler"
	INTERPRETER LanguageType = "interpreter"
)

// LanguageData ...
type LanguageData struct {
	// Standard name of language. Ex: java, c, c++, golang, kotlin, python2, python3
	Name string
	// Implementation Version
	Version string
	// relative directory install path
	Path string
	// Execution name of exec binary. Ex: java
	Exec string
	// Compile name of compile binary. Ex: javac
	CompilerName string `yaml:"compiler-name"`
	// Args when compile exec
	CompileArgs []string `yaml:"compile-args"`
	// Argument pass to compiler-name for checking version
	VersionArg string `yaml:"version-arg"`
	// Type: compiler (need compile then run) | interpreter (don't need compile)
	Type LanguageType
}

// ProjectData store properties of the coflies project
type ProjectData struct {
	Args []string
	// working space path, place the generated/provided code/test files are put,
	// includes project settings, ... necessaries files that need to run the test
	// cases
	Workspace string
	// using `manual` mean we will pass input data as file when run the solution
	// the solution file should not be generated by framework, but directly
	// provided by user then compiled and run
	// by the runner
	// [default] `auto` we will generate real file based on solution (usually
	// only function) provied and language template
	Type string
	// default environments of the project
	Env []string
}

// CodeData store code data of the coflies project
type CodeData struct{}

// TestData store test data of the coflies project
type TestData struct{}

// ResultData store result of the coflies project
type ResultData struct {
	Stdout string
	Stderr string
}

func MakeLanguage(projectPath string, name string, version string) (LanguageData, error) {
	yamlFile, err := ioutil.ReadFile(projectPath + "/config/" + name + "/" + version + "/language.yaml")
	if err != nil {
		log.Errorf("Can't find language configuration. Error: %v\nRetry using default location...", err)
		yamlFile, err = ioutil.ReadFile("languages/" + name + "/" + version + "/language.yaml")
	}
	if err != nil {
		return LanguageData{}, fmt.Errorf("Language or Version not supported. Error: %v", err)
	}
	l := LanguageData{
		Name:    name,
		Version: version,
	}
	err = yaml.Unmarshal(yamlFile, &l)
	if err != nil {
		return LanguageData{}, fmt.Errorf("Incorrected language configuration: %v", err)
	}
	//
	_, err = exec.LookPath(l.CompilerName)
	if err != nil {
		return LanguageData{}, fmt.Errorf("Language compiler not installed. %v", err)
	}
	//
	log.Info("Getting compiler version")
	versionCmd := exec.Command(l.CompilerName, l.VersionArg)
	stdout, _ := versionCmd.StdoutPipe()
	err = versionCmd.Start()
	if err != nil {
		return LanguageData{}, fmt.Errorf("Error getting compiler version. %v", err)
	}
	buffer := new(bytes.Buffer)
	buffer.ReadFrom(stdout)

	versionCmd.Wait()
	versionStr := buffer.String()

	if !strings.Contains(versionStr, l.Version) {
		return LanguageData{}, fmt.Errorf("Version not match. Please install %s-%s", l.CompilerName, l.Version)
	}

	return l, nil
}

func MakeProject(projectPath string, name string) (ProjectData, error) {
	yamlFile, err := ioutil.ReadFile(projectPath + "/projects/" + name + "/project-data.yaml")
	if err != nil {
		log.Errorf("Can't find project configuration. Error: %v\nRetry using default location...", err)
		yamlFile, err = ioutil.ReadFile("projects/" + name + "/project-data.yaml")
	}
	if err != nil {
		return ProjectData{}, fmt.Errorf("Error: %v", err)
	}
	p := ProjectData{}
	err = yaml.Unmarshal(yamlFile, &p)
	if err != nil {
		return ProjectData{}, fmt.Errorf("Project configuration invalid: %v", err)
	}
	//
	if p.Workspace[0] != '/' {
		p.Workspace = projectPath + "/" + p.Workspace
	}
	workingDir := p.Workspace
	if _, err = os.Stat(workingDir); os.IsNotExist(err) {
		log.Info("Working space not existed. Creating...")
		err = os.MkdirAll(projectPath+"/"+p.Workspace, 0700)
		if err != nil {
			return ProjectData{}, fmt.Errorf("Workspace not existed. Error: %v", err)
		}
	}

	return p, nil
}
